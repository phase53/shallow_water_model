!-----------------------------------------------------------------------  
! Shallow Water Model.
! Copyright(c) 2025 Shuya Akamatsu.
!
!     This model uses ISPACK-3.2.2 for spherical harmonic transforms in 
! spectral-space computations.
! 
! History: 2025/07/29 Akamatsu, created.
!          2025/11/23 Akamatsu, last fixed.
!-----------------------------------------------------------------------  
MODULE GLOBALS
  USE ISO_C_BINDING
!----初期パラメタ-------------------------------------------------------
  CHARACTER(128),PARAMETER :: DATPAS='../dat/' !データディレクトリパス
  CHARACTER(128),PARAMETER :: FNZETS='ZETA_S' !出力ファイル名
  CHARACTER(128),PARAMETER :: FNDIVS='DIV_S'
  CHARACTER(128),PARAMETER :: FNDPHS='DEPTH_S'
  CHARACTER(128),PARAMETER :: ADDON='.dat' !拡張子
  CHARACTER(128),PARAMETER :: FNLATD='LAT.dat'
  INTEGER(8),PARAMETER :: JM=512 !緯度方向格子点数
  INTEGER(8),PARAMETER :: IM=1024 !経度方向格子点数
  INTEGER(8),PARAMETER :: NN=341 !切断波数
  INTEGER(8),PARAMETER :: MM=NN
  INTEGER(8),PARAMETER :: NM=NN+1
  INTEGER(8),PARAMETER :: NT=NN
  INTEGER(8),PARAMETER :: DAY=100 !計算日数
  INTEGER(8),PARAMETER :: DAYSTP=500 !１日あたりの時間ステップ数
  INTEGER(8),PARAMETER :: STEP=DAY*DAYSTP !時間ステップ数
  REAL(8),PARAMETER :: PI=3.141592653589793D0 !円周率
  REAL(8),PARAMETER :: VSCSTY=10._8/(DBLE(MM*(MM+1))**10) !粘性係数
  REAL(8),PARAMETER :: OMEGA=2._8*PI !球自転角速度
  REAL(8),PARAMETER :: H=1._8/DAYSTP !タイムステップ幅
  REAL(8),PARAMETER :: ID=PI !初期水深場の中心経度
  REAL(8),PARAMETER :: JD=0.D0 !初期水深場の中心経度
  REAL(8),PARAMETER :: BETA=10.D0 !初期水深場の広がり
!----初期値ファイルを指定する場合，ここにfalenameを入力-----------------
  CHARACTER(128),PARAMETER :: INZETS='hoge' !渦度場  
  CHARACTER(128),PARAMETER :: INDIVS='hoge' !発散場                 
  CHARACTER(128),PARAMETER :: INDPHS='hoge' !水深場
  LOGICAL :: RD=.FALSE. !初期値ファイルを指定した場合, .TRUE. とする
  INTEGER(8),PARAMETER :: SSTEP=0 !計算開始日数(デフォルト：0)
!----ISPACK用-----------------------------------------------------------    
  REAL(8),SAVE :: T(IM*3/2)
  REAL(8),SAVE :: R(((MM+1)*(2*NM-MM-1)+1)/4*3+(2*NM-MM)*(MM+1)/2+MM+1)
  REAL(8),SAVE :: C((2*NT-MM+1)*(MM+1))
  REAL(8),SAVE :: D(NT+1+MM*(2*NT-MM+1),2)
  REAL(8),DIMENSION(:,:),POINTER :: P
  REAL(8),DIMENSION(:),POINTER :: W
  INTEGER(8),SAVE :: IT(IM/2) 
  INTEGER(8),SAVE :: JC(MM*(2*NM-MM-1)/16+MM)
  INTEGER(8),SAVE :: L
!----データ配列---------------------------------------------------------
  REAL(8),DIMENSION(:,:),POINTER :: GZETAP
  REAL(8),DIMENSION(:,:),POINTER :: GZETAI
  REAL(8),DIMENSION(:,:),POINTER :: GDIVI
  REAL(8),DIMENSION(:,:),POINTER :: GDPHI
  REAL(8),DIMENSION(:,:),POINTER :: GZETA
  REAL(8),DIMENSION(:,:),POINTER :: GDPH
  REAL(8),DIMENSION(:,:),POINTER :: GU
  REAL(8),DIMENSION(:,:),POINTER :: GV
  REAL(8),DIMENSION(:,:),POINTER :: GE
  REAL(8),DIMENSION(:,:),POINTER :: MID
  REAL(8),SAVE :: SZETAP((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SZETAI((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SDIVI((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SDPHI((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SU((2*NN+3-MM)*MM+NN+2)
  REAL(8),SAVE :: SV((2*NN+3-MM)*MM+NN+2)
  REAL(8),SAVE :: SPSI((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SXI((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SUPSI((2*NN+3-MM)*MM+NN+2)
  REAL(8),SAVE :: SUXI((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SUXIR((2*NN+3-MM)*MM+NN+2)
  REAL(8),SAVE :: SVPSI((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SVXI((2*NN+3-MM)*MM+NN+2)
  REAL(8),SAVE :: SVPSIR((2*NN+3-MM)*MM+NN+2)
  REAL(8),SAVE :: SUQ((2*NN+3-MM)*MM+NN+2)
  REAL(8),SAVE :: SVQ((2*NN+3-MM)*MM+NN+2)
  REAL(8),SAVE :: SUH((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SVH((2*NN+3-MM)*MM+NN+2)
  REAL(8),SAVE :: SE((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SELP((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SDPHLP((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SDLUQ((2*NN+3-MM)*MM+NN+2)
  REAL(8),SAVE :: SDPVQ((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SDLUQR((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SDLVQ((2*NN+3-MM)*MM+NN+2)
  REAL(8),SAVE :: SDPUQ((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SDLVQR((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SDLUH((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: SDPVH((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: VAL((2*NN+1-MM)*MM+NN+1,3)
  REAL(8),SAVE :: K1((2*NN+1-MM)*MM+NN+1,3)
  REAL(8),SAVE :: K2((2*NN+1-MM)*MM+NN+1,3)
  REAL(8),SAVE :: K3((2*NN+1-MM)*MM+NN+1,3)
  REAL(8),SAVE :: K4((2*NN+1-MM)*MM+NN+1,3)
  REAL(8),SAVE :: TMP1((2*NN+1-MM)*MM+NN+1,3)
  REAL(8),SAVE :: TMP2((2*NN+1-MM)*MM+NN+1,3)
  REAL(8),SAVE :: TMP3((2*NN+1-MM)*MM+NN+1,3)
  REAL(8),SAVE :: RSLVNT((2*NN+1-MM)*MM+NN+1,3)
  REAL(8),SAVE :: A((2*NN+1-MM)*MM+NN+1)
  REAL(8),SAVE :: LAT(JM)
  REAL(8),SAVE :: LON(IM)
  REAL(8),SAVE :: IND
  REAL(8),SAVE :: THALF
  INTEGER(8),SAVE :: TMP
  INTEGER(8),SAVE :: I
  INTEGER(8),SAVE :: J
  INTEGER(8),SAVE :: N
  INTEGER(8),SAVE :: M
  CHARACTER(99) :: NOWDAY
!----ポインタ用---------------------------------------------------------
  TYPE(C_PTR) :: PP
  TYPE(C_PTR) :: PW
  TYPE(C_PTR) :: PZETAP
  TYPE(C_PTR) :: PZETAI
  TYPE(C_PTR) :: PDIVI
  TYPE(C_PTR) :: PDPHI
  TYPE(C_PTR) :: PZETA
  TYPE(C_PTR) :: PDPH
  TYPE(C_PTR) :: PU
  TYPE(C_PTR) :: PV
  TYPE(C_PTR) :: PE
  TYPE(C_PTR) :: PMID
END MODULE GLOBALS

MODULE SUBPROGS
  USE ISO_C_BINDING
  USE GLOBALS
  IMPLICIT NONE
CONTAINS
  SUBROUTINE RK4
    !$OMP PARALLEL
    !$OMP DO
    DO I=1,(2*NN+1-MM)*MM+NN+1    
      VAL(I,1)=SZETAI(I)
      VAL(I,2)=SDIVI(I)
      VAL(I,3)=SDPHI(I)
    ENDDO
    !$OMP END DO
    !$OMP END PARALLEL
    DO TMP=SSTEP,STEP
      IF(MOD(TMP,DAYSTP)<0.0001) THEN
        WRITE(NOWDAY,'(I4.4)') INT(DBLE(TMP)/DAYSTP)
        OPEN(UNIT=11,&
        FILE=TRIM(DATPAS)//TRIM(FNZETS)//TRIM(NOWDAY)//TRIM(ADDON),&
        FORM='UNFORMATTED',ACCESS='DIRECT',&
        RECL=((2*NN+1-MM)*MM+NN+1)*8,CONVERT='BIG_ENDIAN',&
        STATUS='REPLACE')
        OPEN(UNIT=12,&
        FILE=TRIM(DATPAS)//TRIM(FNDIVS)//TRIM(NOWDAY)//TRIM(ADDON),&
        FORM='UNFORMATTED',ACCESS='DIRECT',&
        RECL=((2*NN+1-MM)*MM+NN+1)*8,CONVERT='BIG_ENDIAN',&
        STATUS='REPLACE')
        OPEN(UNIT=13,&
        FILE=TRIM(DATPAS)//TRIM(FNDPHS)//TRIM(NOWDAY)//TRIM(ADDON),&
        FORM='UNFORMATTED',ACCESS='DIRECT',&
        RECL=((2*NN+1-MM)*MM+NN+1)*8,CONVERT='BIG_ENDIAN',&
        STATUS='REPLACE')
        WRITE(11,REC=1) VAL(:,1)+SZETAP(:)
        WRITE(12,REC=1) VAL(:,2) 
        WRITE(13,REC=1) VAL(:,3)
        CLOSE(11)
        CLOSE(12)
        CLOSE(13)
      ENDIF
      WRITE(*,*) 'NOW STEP is',TMP
      !１段階目
      CALL RHS(VAL(:,1),VAL(:,2),VAL(:,3),K1(:,1),K1(:,2),K1(:,3))
      !$OMP PARALLEL
      DO J=1,3
        !$OMP DO
        DO I=1,(2*NN+1-MM)*MM+NN+1
          K1(I,J)=H*K1(I,J)
          TMP1(I,J)=RSLVNT(I,J)*(VAL(I,J)+0.5D0*K1(I,J))
        ENDDO
        !$OMP END DO
      ENDDO
      !$OMP END PARALLEL
      !２段階目
      CALL RHS(TMP1(:,1),TMP1(:,2),TMP1(:,3),K2(:,1),K2(:,2),K2(:,3))
      !$OMP PARALLEL
      DO J=1,3
        !$OMP DO
        DO I=1,(2*NN+1-MM)*MM+NN+1
          K2(I,J)=H*K2(I,J)
          TMP2(I,J)=RSLVNT(I,J)*VAL(I,J)+0.5D0*K2(I,J)
        ENDDO
        !$OMP END DO
      ENDDO
      !$OMP END PARALLEL
      !３段階目
      CALL RHS(TMP2(:,1),TMP2(:,2),TMP2(:,3),K3(:,1),K3(:,2),K3(:,3))
      !$OMP PARALLEL
      DO J=1,3
        !$OMP DO
        DO I=1,(2*NN+1-MM)*MM+NN+1
          K3(I,J)=H*K3(I,J)
          TMP3(I,J)=RSLVNT(I,J)*(RSLVNT(I,J)*VAL(I,J)+K3(I,J))
        ENDDO
        !$OMP END DO
      ENDDO
      !$OMP END PARALLEL
      !４段階目
      CALL RHS(TMP3(:,1),TMP3(:,2),TMP3(:,3),K4(:,1),K4(:,2),K4(:,3))
      !$OMP PARALLEL
      DO J=1,3
        !$OMP DO
        DO I=1,(2*NN+1-MM)*MM+NN+1
          K4(I,J)=H*K4(I,J)

          VAL(I,J)=RSLVNT(I,J)*(RSLVNT(I,J)*(VAL(I,J)+K1(I,J)/6._8)+&
          (K2(I,J)+K3(I,J))/3._8)+K4(I,J)/6._8
        ENDDO
        !$OMP END DO
      ENDDO
      !$OMP END PARALLEL
    ENDDO
  END SUBROUTINE RK4

  SUBROUTINE RHS(SZETA,SDIV,SDPH,SZETAO,SDIVO,SDPHO)
    REAL(8),INTENT(IN) :: SZETA((2*NN+1-MM)*MM+NN+1)
    REAL(8),INTENT(IN) :: SDIV((2*NN+1-MM)*MM+NN+1)
    REAL(8),INTENT(IN) :: SDPH((2*NN+1-MM)*MM+NN+1)
    REAL(8),INTENT(OUT) :: SZETAO((2*NN+1-MM)*MM+NN+1)
    REAL(8),INTENT(OUT) :: SDIVO((2*NN+1-MM)*MM+NN+1)
    REAL(8),INTENT(OUT) :: SDPHO((2*NN+1-MM)*MM+NN+1)
    
    CALL SXCLAP(MM,NT,SZETA,SPSI,D,2_8)
    CALL SXCLAP(MM,NT,SDIV,SXI,D,2_8)
        
    CALL SXCS2Y(MM,NT,SPSI,SUPSI,C)
    CALL SXCS2X(MM,NT,SXI,SUXI)
    CALL SXCRPK(MM,NT,NT+1,SUXI,SUXIR)
    SU=-SUPSI+SUXIR 
    CALL SXTS2G(MM,NM,NN+1,IM,JM,SU,GU,IT,T,P,R,JC,W,1_8)

    CALL SXCS2X(MM,NT,SPSI,SVPSI)
    CALL SXCS2Y(MM,NT,SXI,SVXI,C)
    CALL SXCRPK(MM,NT,NT+1,SVPSI,SVPSIR)
    SV=SVPSIR+SVXI
    CALL SXTS2G(MM,NM,NN+1,IM,JM,SV,GV,IT,T,P,R,JC,W,1_8)

    CALL SXTS2G(MM,NM,NN,IM,JM,SZETA,GZETA,IT,T,P,R,JC,W,0_8)
    CALL SXTS2G(MM,NM,NN,IM,JM,SDPH,GDPH,IT,T,P,R,JC,W,0_8)

    MID=GU*(GZETA+GZETAP)   
    CALL SXTG2S(MM,NM,NN+1,IM,JM,SUQ,MID,IT,T,P,R,JC,W,1_8)
    MID=GV*(GZETA+GZETAP)    
    CALL SXTG2S(MM,NM,NN+1,IM,JM,SVQ,MID,IT,T,P,R,JC,W,1_8)
    MID=GU*GDPH    
    CALL SXTG2S(MM,NM,NN,IM,JM,SUH,MID,IT,T,P,R,JC,W,1_8)
    MID=GV*GDPH
    CALL SXTG2S(MM,NM,NN+1,IM,JM,SVH,MID,IT,T,P,R,JC,W,1_8)

    GE=(GU**2+GV**2)/2._8
    CALL SXTG2S(MM,NM,NN,IM,JM,SE,GE,IT,T,P,R,JC,W,0_8)
    CALL SXCLAP(MM,NT,SE,SELP,D,1_8)
    CALL SXCLAP(MM,NT,SDPH,SDPHLP,D,1_8)

    CALL SXCS2X(MM,NT+1,SUQ,SDLUQ)
    CALL SXCY2S(MM,NT,SVQ,SDPVQ,C)
    CALL SXCRPK(MM,NT+1,NT,SDLUQ,SDLUQR)
    SZETAO=-SDPVQ-SDLUQR

    CALL SXCS2X(MM,NT+1,SVQ,SDLVQ)
    CALL SXCY2S(MM,NT,SUQ,SDPUQ,C)
    CALL SXCRPK(MM,NT+1,NT,SDLVQ,SDLVQR)
    SDIVO=SDLVQR-SDPUQ-SELP-SDPHLP

    CALL SXCS2X(MM,NT,SUH,SDLUH)
    CALL SXCY2S(MM,NT,SVH,SDPVH,C)
    SDPHO=-SDLUH-SDPVH
  END SUBROUTINE RHS

  SUBROUTINE MKRSLV
    DO I=1_8,(2*NN+1-MM)*MM+NN+1
      CALL SXL2NM(NN,I,N,M)
      A(I)=-((N*(N+1._8))**10)*VSCSTY
    ENDDO
    THALF=H/2._8
    DO I=1_8,(2*NN+1-MM)*MM+NN+1
      RSLVNT(I,:)=EXP(A(I)*THALF)
    ENDDO
  END SUBROUTINE MKRSLV

  SUBROUTINE READY
    CALL MXALLC(PP,JM/2*(2*MM+5))
    CALL MXALLC(PW,JM*IM)
    CALL MXALLC(PZETAP,JM*IM)
    CALL MXALLC(PZETAI,JM*IM)
    CALL MXALLC(PDIVI,JM*IM)
    CALL MXALLC(PDPHI,JM*IM)
    CALL MXALLC(PZETA,JM*IM)
    CALL MXALLC(PDPH,JM*IM)
    CALL MXALLC(PU,JM*IM)
    CALL MXALLC(PV,JM*IM)
    CALL MXALLC(PE,JM*IM)
    CALL MXALLC(PMID,JM*IM)
    CALL C_F_POINTER(PP,P,[JM/2,2*MM+5])
    CALL C_F_POINTER(PW, W, [IM*JM])
    CALL C_F_POINTER(PZETAP,GZETAP,[IM,JM])
    CALL C_F_POINTER(PZETAI,GZETAI,[IM,JM])
    CALL C_F_POINTER(PDIVI,GDIVI,[IM,JM])
    CALL C_F_POINTER(PDPHI,GDPHI,[IM,JM])
    CALL C_F_POINTER(PZETA,GZETA,[IM,JM])
    CALL C_F_POINTER(PDPH,GDPH,[IM,JM])
    CALL C_F_POINTER(PU,GU,[IM,JM])
    CALL C_F_POINTER(PV,GV,[IM,JM])
    CALL C_F_POINTER(PE,GE,[IM,JM])
    CALL C_F_POINTER(PMID,MID,[IM,JM])

    CALL SXINI1(MM,NM,IM,IT,T,R)
    CALL SXINI2(MM,NM,JM,1_8,P,R,JC)
    CALL SXINIC(MM,NT,C)
    CALL SXINID(MM,NT,D)

    DO I=1,JM/2_8
      LAT(JM/2_8+I)=P(I,1)
      LAT(JM/2_8-I+1)=-P(I,1)
    ENDDO
    LAT(:)=ASIN(LAT(:))
    DO J=1,IM 
      LON(J)=(J-1._8)*2._8*PI/IM
    ENDDO

    DO I=1,JM
      GZETAP(:,I)=2._8*OMEGA*SIN(LAT(I))
    ENDDO
    CALL SXTG2S(MM,NM,NT,IM,JM,SZETAP,GZETAP,IT,T,P,R,JC,W,0_8)      
  END SUBROUTINE READY

  SUBROUTINE MKINIT
    DO J=1,JM
      DO I=1,IM
        IND=SIN(LAT(J))*SIN(JD)+SQRT((1._8-SIN(LAT(J))**2)*&
        (1._8-SIN(JD)**2))*COS(LON(I)-ID) 
        GDPHI(I,J)=1._8+&
        0.1D0*(EXP(BETA*(IND-1._8))-(1._8-EXP(-2._8*BETA))/(2._8*BETA))    
      ENDDO
    ENDDO

    CALL SXTG2S(MM,NM,NT,IM,JM,SZETAI,GZETAI,IT,T,P,R,JC,W,0_8)
    CALL SXTG2S(MM,NM,NT,IM,JM,SDIVI,GDIVI,IT,T,P,R,JC,W,0_8)
    CALL SXTG2S(MM,NM,NT,IM,JM,SDPHI,GDPHI,IT,T,P,R,JC,W,0_8)
  END SUBROUTINE MKINIT

  SUBROUTINE RDDATA
    OPEN(UNIT=21,FILE=TRIM(DATPAS)//TRIM(INZETS),FORM='UNFORMATTED',&
    ACCESS='DIRECT',RECL=((2*NN+1-MM)*MM+NN+1)*8,&
    CONVERT='BIG_ENDIAN',STATUS='OLD')
    OPEN(UNIT=22,FILE=TRIM(DATPAS)//TRIM(INDIVS),FORM='UNFORMATTED',&
    ACCESS='DIRECT',RECL=((2*NN+1-MM)*MM+NN+1)*8,&
    CONVERT='BIG_ENDIAN',STATUS='OLD')
    OPEN(UNIT=23,FILE=TRIM(DATPAS)//TRIM(INDPHS),FORM='UNFORMATTED',&
    ACCESS='DIRECT',RECL=((2*NN+1-MM)*MM+NN+1)*8,&
    CONVERT='BIG_ENDIAN',STATUS='OLD')
    READ(21,REC=1) SZETAI(:)
    READ(22,REC=1) SDIVI(:)
    READ(23,REC=1) SDPHI(:)
    CLOSE(21)
    CLOSE(22)
    CLOSE(23)
  END SUBROUTINE RDDATA

  SUBROUTINE MKLATD
    OPEN(UNIT=14,FILE=TRIM(DATPAS)//TRIM(FNLATD),FORM='UNFORMATTED',&
    ACCESS='DIRECT',RECL=JM*8,&
    CONVERT='BIG_ENDIAN',STATUS='REPLACE')
    WRITE(14,REC=1) LAT(:)
    CLOSE(14)
  END SUBROUTINE MKLATD

  SUBROUTINE BYE 
    CALL MXFREE(PP)
    CALL MXFREE(PW)
    CALL MXFREE(PZETAP)
    CALL MXFREE(PZETAI)
    CALL MXFREE(PDIVI)
    CALL MXFREE(PDPHI)
    CALL MXFREE(PZETA)
    CALL MXFREE(PDPH)
    CALL MXFREE(PU)
    CALL MXFREE(PV)
    CALL MXFREE(PE)
    CALL MXFREE(PMID)
  END SUBROUTINE BYE 

  SUBROUTINE WRTDAT
    WRITE(*,*) '--------Model Settings--------'
    WRITE(*,*) 'Latitude grid points =',JM
    WRITE(*,*) 'longitude grid points =',IM
    WRITE(*,*) 'truncation wavenumber =',NN
    WRITE(*,*) '--Output file name (../dat/)--'
    WRITE(*,*) 'vorticity spectrum datafile : ',FNZETS
    WRITE(*,*) 'divergence spectrum datafile : ',FNDIVS
    WRITE(*,*) 'water depth spectrum datafile : ',FNDPHS
    WRITE(*,*) 'gaussian latitude datafile : ',FNLATD
  END SUBROUTINE WRTDAT
END MODULE SUBPROGS 

PROGRAM MAIN
    USE SUBPROGS
    USE GLOBALS
    IMPLICIT NONE

    CALL WRTDAT
    CALL READY
    IF(RD) THEN
      CALL RDDATA
    ELSE
      CALL MKINIT
    ENDIF
    CALL MKLATD
    CALL MKRSLV
    CALL RK4
    CALL BYE
END PROGRAM MAIN
